<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DXF 3D Viewer - Rectangle Box</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #e0e0e0 0%, #f5f5f5 100%);
            overflow: hidden;
        }
        
        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        
        #info-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.85);
            color: #fff;
            padding: 20px;
            border-radius: 12px;
            font-size: 14px;
            line-height: 1.8;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            max-width: 350px;
            z-index: 100;
            max-height: 80vh;
            overflow-y: auto;
        }
        
        #info-panel h2 {
            color: #00ff88;
            font-size: 18px;
            margin-bottom: 12px;
            border-bottom: 2px solid #00ff88;
            padding-bottom: 8px;
        }
        
        .layer-info {
            display: flex;
            align-items: center;
            margin: 8px 0;
            padding: 6px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 6px;
        }
        
        .color-box {
            width: 25px;
            height: 25px;
            border-radius: 4px;
            margin-right: 10px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }
        
        #stats {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.85);
            color: #00ff88;
            padding: 15px;
            border-radius: 12px;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(0, 255, 136, 0.3);
            font-family: 'Courier New', monospace;
            font-size: 12px;
            z-index: 100;
            min-width: 180px;
        }
        
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: #00ff88;
            padding: 30px 50px;
            border-radius: 12px;
            font-size: 18px;
            z-index: 200;
            text-align: center;
        }
        
        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.1);
            border-top: 4px solid #00ff88;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        #file-info {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.85);
            color: #00ff88;
            padding: 10px 15px;
            border-radius: 8px;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(0, 255, 136, 0.3);
            font-family: 'Courier New', monospace;
            font-size: 11px;
            z-index: 100;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    
    <div id="loading">
        <div>üèóÔ∏è Loading DXF file...</div>
        <div class="spinner"></div>
    </div>
    
    <div id="info-panel">
        <h2>üè¢ 3D Viewer</h2>
        <div id="layer-list"></div>
        <div style="margin-top: 15px; padding-top: 10px; border-top: 1px solid rgba(255,255,255,0.2); font-size: 12px;">
            <small>üñ±Ô∏è Mouse: Rotate<br>üéØ Wheel: Zoom<br>üîÑ Right-click: Pan</small>
        </div>
    </div>
    
    <div id="stats">
        <div id="entity-count">Entities: Calculating...</div>
        <div id="bounds">Bounds: Calculating...</div>
    </div>

    <div id="file-info">
        üìÑ <span id="current-file">-</span>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.158.0/examples/jsm/"
            }
        }
    </script>
    
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        
        // Load configuration from config/config.json
        let LAYER_COLOR_MAP = {};
        let LAYER_HEIGHT_MAP = {};
        let DEFAULT_HEIGHT = 2000;
        const defaultColorPalette = [
            0xff6b6b, 0x4ecdc4, 0xffe66d, 0x95e1d3,
            0xf38181, 0xaa96da, 0xfcbad3, 0xa8e6cf
        ];
        
        async function loadConfig() {
            try {
                const response = await fetch('config.json');
                const config = await response.json();
                
                // Parse layers configuration
                const layers = config.layers || {};
                
                for (const [layerKey, layerConfig] of Object.entries(layers)) {
                    const layerName = layerKey.toUpperCase();
                    // Parse hex color string to integer
                    const colorStr = layerConfig.color;
                    const colorInt = parseInt(colorStr, 16);
                    
                    LAYER_COLOR_MAP[layerName] = colorInt;
                    LAYER_HEIGHT_MAP[layerName] = layerConfig.height;
                }
                
                console.log('‚úì Configuration loaded:', LAYER_COLOR_MAP, LAYER_HEIGHT_MAP);
            } catch (error) {
                console.warn('Failed to load config.json, using defaults:', error);
            }
        }
        
        // Global variables
        let initialCameraPos, initialControlsTarget;
        const bounds = {
            minX: Infinity, maxX: -Infinity,
            minY: Infinity, maxY: -Infinity
        };
        const layersFound = new Set();
        const entityCount = {};
        
        // Three.js basic setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xeeeeee);
        scene.fog = new THREE.Fog(0xeeeeee, 5000, 50000);
        
        const camera = new THREE.PerspectiveCamera(
            60,
            window.innerWidth / window.innerHeight,
            1,
            1000000
        );
        
        const renderer = new THREE.WebGLRenderer({ 
            antialias: true,
            alpha: true 
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        document.getElementById('canvas-container').appendChild(renderer.domElement);
        
        // OrbitControls setup
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.screenSpacePanning = false;
        controls.minDistance = 100;
        controls.maxDistance = 100000;
        
        // Lighting setup
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        
        const directionalLight1 = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight1.position.set(5000, 8000, 5000);
        directionalLight1.castShadow = true;
        scene.add(directionalLight1);
        
        const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.4);
        directionalLight2.position.set(-5000, 5000, -5000);
        scene.add(directionalLight2);

        // Grid helper
        const gridHelper = new THREE.GridHelper(50000, 50, 0x444444, 0x222222);
        scene.add(gridHelper);

        // Axes helper
        const axesHelper = new THREE.AxesHelper(3000);
        scene.add(axesHelper);
        
        const hemisphereLight = new THREE.HemisphereLight(0x8888ff, 0x444444, 0.3);
        scene.add(hemisphereLight);
        
        // Get color by layer
        function getLayerColor(layer, fallbackIndex) {
            const upperLayer = layer.toUpperCase();
            if (LAYER_COLOR_MAP[upperLayer] !== undefined) {
                return LAYER_COLOR_MAP[upperLayer];
            }
            return defaultColorPalette[fallbackIndex % defaultColorPalette.length];
        }
        
        // Update bounds
        function updateBounds(x, y) {
            if (x < bounds.minX) bounds.minX = x;
            if (x > bounds.maxX) bounds.maxX = x;
            if (y < bounds.minY) bounds.minY = y;
            if (y > bounds.maxY) bounds.maxY = y;
        }
        
        // Parse DXF
        function parseDXF(dxfText) {
            const entities = [];
            const lines = dxfText.split('\n').map(line => line.trim());
            
            let i = 0;
            let inEntitiesSection = false;
            
            while (i < lines.length) {
                const line = lines[i];
                
                if (line === 'ENTITIES') {
                    inEntitiesSection = true;
                    i++;
                    continue;
                }
                
                if (line === 'ENDSEC' && inEntitiesSection) {
                    break;
                }
                
                if (inEntitiesSection && line === 'LWPOLYLINE') {
                    const entity = { type: 'LWPOLYLINE', vertices: [], closed: false };
                    i++;
                    
                    while (i < lines.length && lines[i] !== '0') {
                        const code = parseInt(lines[i]);
                        const value = lines[i + 1];
                        
                        if (code === 8) {
                            entity.layer = value;
                        } else if (code === 70) {
                            entity.closed = parseInt(value) === 1;
                        } else if (code === 90) {
                            entity.vertexCount = parseInt(value);
                        } else if (code === 10) {
                            const x = parseFloat(value);
                            const y = parseFloat(lines[i + 3]);
                            entity.vertices.push({ x, y });
                            i += 2;
                        }
                        i += 2;
                    }
                    
                    entities.push(entity);
                    continue;
                }
                
                // Parse POLYLINE (3D polyline)
                if (inEntitiesSection && line === 'POLYLINE') {
                    const entity = { type: 'LWPOLYLINE', vertices: [], closed: false };
                    let polylineLayer = null;
                    i++;
                    
                    // Read POLYLINE header
                    while (i < lines.length && lines[i] !== '0') {
                        const code = parseInt(lines[i]);
                        const value = lines[i + 1];
                        
                        if (code === 8) {
                            polylineLayer = value;
                        } else if (code === 70) {
                            entity.closed = (parseInt(value) & 1) === 1;
                        }
                        i += 2;
                    }
                    
                    entity.layer = polylineLayer;
                    
                    // Read VERTEX entities
                    while (i < lines.length) {
                        if (lines[i] === '0' && lines[i + 1] === 'VERTEX') {
                            i += 2;
                            let vx = 0, vy = 0;
                            
                            while (i < lines.length && lines[i] !== '0') {
                                const code = parseInt(lines[i]);
                                const value = lines[i + 1];
                                
                                if (code === 10) {
                                    vx = parseFloat(value);
                                } else if (code === 20) {
                                    vy = parseFloat(value);
                                }
                                i += 2;
                            }
                            
                            entity.vertices.push({ x: vx, y: vy });
                        } else if (lines[i] === '0' && lines[i + 1] === 'SEQEND') {
                            i += 2;
                            break;
                        } else {
                            i++;
                        }
                    }
                    
                    if (entity.vertices.length > 0) {
                        entities.push(entity);
                    }
                    continue;
                }
                
                i++;
            }
            
            console.log(`‚úÖ Parsing complete: ${entities.length} entities`);
            return entities;
        }
        
        // Create 3D box
        function create3DBox(vertices, layer, layerIndex) {
            if (!vertices || vertices.length < 4) return null;
            
            // Get min/max values of rectangle
            let minX = Infinity, maxX = -Infinity;
            let minY = Infinity, maxY = -Infinity;
            
            vertices.forEach(v => {
                if (v.x < minX) minX = v.x;
                if (v.x > maxX) maxX = v.x;
                if (v.y < minY) minY = v.y;
                if (v.y > maxY) maxY = v.y;
            });
            
            let width = maxX - minX;
            let depth = maxY - minY;
            
            // Special handling for FLOOR layer - flat at z=0
            if (layer.toUpperCase() === 'FLOOR') {
                const centerX = (minX + maxX) / 2;
                const centerY = (minY + maxY) / 2;
                
                const geometry = new THREE.PlaneGeometry(width, depth);
                const color = getLayerColor(layer, layerIndex);
                const material = new THREE.MeshStandardMaterial({
                    color: color,
                    roughness: 0.8,
                    metalness: 0.2,
                    side: THREE.DoubleSide
                });
                
                const mesh = new THREE.Mesh(geometry, material);
                mesh.rotation.x = -Math.PI / 2;
                mesh.position.set(centerX, 0, -centerY);
                mesh.receiveShadow = true;
                
                return mesh;
            }
            
            // Regular 3D boxes for other layers
            const upperLayer = layer.toUpperCase();
            const height = LAYER_HEIGHT_MAP[upperLayer] || DEFAULT_HEIGHT;
            
            // Set minimum values for doors with zero dimensions
            if (width < 1) width = 100;
            if (depth < 1) depth = 100;
            
            const centerX = (minX + maxX) / 2;
            const centerY = (minY + maxY) / 2;
            
            const geometry = new THREE.BoxGeometry(width, height, depth);
            
            const color = getLayerColor(layer, layerIndex);
            const material = new THREE.MeshStandardMaterial({
                color: color,
                roughness: 0.7,
                metalness: 0.3,
                transparent: true,
                opacity: 0.85
            });
            
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(centerX, height / 2, -centerY);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            
            return mesh;
        }
        
        // Render entities
        function renderEntities(entities) {
            const layerMap = {};
            let layerIndex = 0;
            
            entities.forEach(entity => {
                try {
                    const layer = entity.layer || 'DEFAULT';
                    
                    if (!layerMap[layer]) {
                        layerMap[layer] = layerIndex++;
                    }
                    
                    layersFound.add(layer);
                    
                    if (!entityCount[layer]) entityCount[layer] = 0;
                    
                    if (entity.type === 'LWPOLYLINE' && entity.vertices && entity.vertices.length >= 4) {
                        const mesh = create3DBox(entity.vertices, layer, layerMap[layer]);
                        if (mesh) {
                            scene.add(mesh);
                            entityCount[layer]++;
                            
                            entity.vertices.forEach(v => {
                                if (v && v.x !== undefined && v.y !== undefined) {
                                    updateBounds(v.x, v.y);
                                }
                            });
                        }
                    }
                    
                } catch (e) {
                    console.warn('‚ùå Entity rendering failed:', e, entity);
                }
            });
        }
        
        // Setup camera
        function setupCamera() {
            if (bounds.minX === Infinity) {
                camera.position.set(0, 10000, 10000);
                controls.target.set(0, 0, 0);
            } else {
                const centerX = (bounds.minX + bounds.maxX) / 2;
                const centerY = (bounds.minY + bounds.maxY) / 2;
                const sizeX = bounds.maxX - bounds.minX;
                const sizeY = bounds.maxY - bounds.minY;
                const maxSize = Math.max(sizeX, sizeY);
                
                controls.target.set(centerX, 1000, -centerY);
                camera.position.set(
                    centerX + maxSize * 0.8,
                    maxSize * 0.8,
                    -centerY + maxSize * 1.2
                );
                
                initialCameraPos = camera.position.clone();
                initialControlsTarget = controls.target.clone();
            }
            
            controls.update();
        }
        
        // Update UI
        function updateStats() {
            const total = Object.values(entityCount).reduce((a, b) => a + b, 0);
            
            let countHTML = `Entities: ${total}<br><small>`;
            const sortedLayers = Array.from(layersFound).sort();
            for (const layer of sortedLayers) {
                const count = entityCount[layer] || 0;
                countHTML += `${layer}: ${count}<br>`;
            }
            countHTML += '</small>';
            document.getElementById('entity-count').innerHTML = countHTML;
            
            if (bounds.minX !== Infinity) {
                const sizeX = (bounds.maxX - bounds.minX).toFixed(0);
                const sizeY = (bounds.maxY - bounds.minY).toFixed(0);
                document.getElementById('bounds').innerHTML = `
                    Bounds:<br>
                    <small>
                    X: ${sizeX}mm<br>
                    Y: ${sizeY}mm
                    </small>
                `;
            }
            
            // Update layer info panel
            let layerHTML = '';
            const sortedLayersForDisplay = Array.from(layersFound).sort();
            sortedLayersForDisplay.forEach((layer, idx) => {
                const color = getLayerColor(layer, idx);
                const colorHex = '#' + color.toString(16).padStart(6, '0');
                layerHTML += `
                    <div class="layer-info">
                        <div class="color-box" style="background: ${colorHex};"></div>
                        <div>
                            <strong>${layer}</strong><br>
                            <small style="color: #aaa;">${entityCount[layer] || 0} objects</small>
                        </div>
                    </div>
                `;
            });
            document.getElementById('layer-list').innerHTML = layerHTML;
        }
        
        // Load config first, then load DXF
        const params = new URLSearchParams(window.location.search);
        const dxfFile = params.get('file') || 'data.dxf';
        
        document.getElementById('current-file').textContent = dxfFile;
        
        loadConfig().then(() => {
            return fetch(dxfFile);
        }).then(response => {
            if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
            return response.text();
        }).then(dxfText => {
            console.log('‚úÖ DXF file loaded, size:', dxfText.length);
            const entities = parseDXF(dxfText);
            renderEntities(entities);
            setupCamera();
            updateStats();
            document.getElementById('loading').style.display = 'none';
            console.log('‚úÖ Rendering complete');
        }).catch(error => {
            console.error('‚ùå Load failed:', error);
            document.getElementById('loading').innerHTML = `
                <div style="color: #ff4444;">‚ùå File load failed</div>
                <div style="font-size: 12px; margin-top: 10px;">${error.message}</div>
                <div style="font-size: 10px; margin-top: 10px; color: #aaa;">
                DXF file: ${dxfFile}<br>
                Make sure the file is in the same directory as the HTML.
                </div>
            `;
        });
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        animate();
        
        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>